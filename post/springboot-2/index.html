<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>风袖</title>
<meta name="description" content="烟蛾敛略不胜态，风袖低昂如有情" />
<link rel="shortcut icon" href="https://Zu3zz.github.io//favicon.ico?v=1581859385259">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://Zu3zz.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="风袖 - Atom Feed" href="https://Zu3zz.github.io//atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://Zu3zz.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://Zu3zz.github.io//images/avatar.png?v=1581859385259" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">风袖</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1、配置文件</a></li>
<li><a href="#2-yaml%E8%AF%AD%E6%B3%95">2、 YAML语法</a>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1、基本语法</a></li>
<li><a href="#2-%E5%80%BC%E7%9A%84%E5%86%99%E6%B3%95">2、值的写法</a>
<ul>
<li><a href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E6%99%AE%E9%80%9A%E7%9A%84%E5%80%BC%E6%95%B0%E5%AD%97-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%B8%83%E5%B0%94%E5%80%BC">字面量：普通的值(数字、字符串、布尔值)</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1-map%E5%B1%9E%E6%80%A7%E5%92%8C%E5%80%BC%E9%94%AE%E5%80%BC%E5%AF%B9">对象、Map(属性和值)(键值对)：</a></li>
<li><a href="#%E6%95%B0%E7%BB%84list-set">数组（List、Set）：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%80%BC%E6%B3%A8%E5%85%A5">3、配置文件值注入</a><br>
*
<ul>
<li><a href="#1-properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9C%A8idea%E4%B8%AD%E9%BB%98%E8%AE%A4utf-8%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B9%B1%E7%A0%81">1、properties配置文件在idea中默认utf-8可能会乱码</a></li>
<li><a href="#2-value%E8%8E%B7%E5%8F%96%E5%80%BC%E5%92%8Cconfigurationproperties%E8%8E%B7%E5%8F%96%E5%80%BC%E6%AF%94%E8%BE%83">2、@Value获取值和@ConfigurationProperties获取值比较</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8%E5%85%A5%E5%80%BC%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C">3、配置文件注入值数据校验</a></li>
<li><a href="#4-propertysource-importresource">4、@PropertySource &amp; @ImportResource</a></li>
</ul>
</li>
<li><a href="#4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8D%A0%E4%BD%8D%E7%AC%A6">4、配置文件占位符</a>
<ul>
<li><a href="#1-%E9%9A%8F%E6%9C%BA%E6%95%B0">1、随机数</a></li>
<li><a href="#2-%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%8E%B7%E5%8F%96%E4%B9%8B%E5%89%8D%E9%85%8D%E7%BD%AE%E7%9A%84%E5%80%BC%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%8F%AF%E4%BB%A5%E6%98%AF%E7%94%A8%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC">2、占位符获取之前配置的值，如果没有可以是用:指定默认值</a></li>
</ul>
</li>
<li><a href="#5-profile">5、Profile</a>
<ul>
<li><a href="#1-%E5%A4%9Aprofile%E6%96%87%E4%BB%B6">1、多Profile文件</a></li>
<li><a href="#2-yml%E6%94%AF%E6%8C%81%E5%A4%9A%E6%96%87%E6%A1%A3%E5%9D%97%E6%96%B9%E5%BC%8F">2、yml支持多文档块方式</a></li>
<li><a href="#3-%E6%BF%80%E6%B4%BB%E6%8C%87%E5%AE%9Aprofile">3、激活指定profile</a></li>
</ul>
</li>
<li><a href="#6-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BD%8D%E7%BD%AE">6、配置文件加载位置</a></li>
<li><a href="#7-%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F">7、外部配置加载顺序</a></li>
<li><a href="#8-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86">8、自动配置原理</a>
<ul>
<li><a href="#1-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86">1、<strong>自动配置原理</strong></a></li>
<li><a href="#2-%E7%BB%86%E8%8A%82">2、细节</a>
<ul>
<li><a href="#1-conditional%E6%B4%BE%E7%94%9F%E6%B3%A8%E8%A7%A3spring%E4%B8%AD%E5%8E%9F%E7%94%9F%E7%9A%84conditional%E4%BD%9C%E7%94%A8">1、@Conditional派生注解(Spring中原生的@Conditional作用)</a></li>
<li><a href="#2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%9C%A8%E4%B8%80%E5%AE%9A%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%89%8D%E8%83%BD%E7%94%9F%E6%95%88">2、自动配置类必须在一定的条件下才能生效</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="/projects" class="menu" style="animation-delay: 0.8s">
          项目
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">By 3zz.</div>
    <a class="rss" href="https://Zu3zz.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">SpringBoot系列(2) ---- 配置文件</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-10-10 / 15 min read
        </div>
        
        <div class="post-content yue">
          <p>🎏那么又到了我们SpringBoot系列的第二篇！！<br>
🎀这一篇，我们来讲讲SpringBoot中的配置相关问题，依旧有源码级别的分析哦！</p>
<!-- more -->
<h2 id="1-配置文件">1、配置文件</h2>
<ul>
<li>
<p>Spring Boot使用一个全局的配置文件，配置文件名是固定的</p>
<ol>
<li>application.properties</li>
<li>application.yml</li>
</ol>
</li>
<li>
<p>配置文件的作用：修改SpringBoot自动默认的设置值；SpringBoot在底层都给我们自动配置好了</p>
</li>
<li>
<p>YAML( YAML Ain't Markup Language)</p>
<ul>
<li>
<p>YAML A Markup Language: 是一个标记语言</p>
</li>
<li>
<p>YAML isn't Markup Language: 不是一个标记语言</p>
</li>
<li>
<p>标记语言：</p>
<ul>
<li>
<p>以前的配置文件：大多使用 <strong>xxxx.xml</strong>文件；</p>
</li>
<li>
<p>YAML: <strong>以数据为中心</strong>，比JSON、XML更适合做配置文件</p>
</li>
<li>
<p>YAML配置例子</p>
<pre><code class="language-yml">server:
	port: 8081
</code></pre>
</li>
<li>
<p>XML:</p>
<pre><code class="language-xml">&lt;server&gt;
  &lt;port&gt;8081&lt;/port&gt;
&lt;/server&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-yaml语法">2、 YAML语法</h2>
<h3 id="1-基本语法">1、基本语法</h3>
<ul>
<li>
<p>k:(空格)v : 表示一对键值对(空格必须有)；</p>
</li>
<li>
<p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的</p>
<pre><code class="language-text">server:
	port: 8081
	path: /hello
</code></pre>
</li>
<li>
<p>属性和值也是大小写敏感的</p>
</li>
</ul>
<h3 id="2-值的写法">2、值的写法</h3>
<h4 id="字面量普通的值数字-字符串-布尔值">字面量：普通的值(数字、字符串、布尔值)</h4>
<ul>
<li>
<p>K：V：字面直接来写</p>
</li>
<li>
<p>字符串默认不用加上单引号或者双引号</p>
<ul>
<li>&quot;&quot;:双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表达的意思</li>
</ul>
<pre><code class="language-yaml">name: &quot;zhangsan \n lisi&quot;
输出： zhangsan 换行 lisi
</code></pre>
<ul>
<li>:单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</li>
</ul>
<pre><code class="language-yaml">name: 'zhangsan \n lisi'
输出： zhangsan \n  lisi
</code></pre>
</li>
</ul>
<h4 id="对象-map属性和值键值对">对象、Map(属性和值)(键值对)：</h4>
<ul>
<li>
<p>k：v：在下一行来写对象的属性和值的关系；注意缩进</p>
<ul>
<li>对象还是k：v的方式</li>
</ul>
<pre><code class="language-yaml">friends:
	lastname: zhangsan
	age: 20
</code></pre>
<ul>
<li>行内写法</li>
</ul>
<pre><code class="language-yaml">fridends: {lastName: zhangsan, age: 18}
</code></pre>
</li>
</ul>
<h4 id="数组list-set">数组（List、Set）：</h4>
<ul>
<li>
<p>用- 值表示数组中的一个元素</p>
<pre><code class="language-yaml">pets:
 - cat
 - dot
 - pig
</code></pre>
</li>
<li>
<p>行内写法</p>
<pre><code class="language-yaml">pets: [cat,dog,pig]
</code></pre>
</li>
</ul>
<h2 id="3-配置文件值注入">3、配置文件值注入</h2>
<ul>
<li>配置文件</li>
</ul>
<pre><code class="language-yaml">person:
	lastName: hello
	age: 18
	boss: false
	birth: 2019/10/7
	maps: {k1:v1, k2:v2}
	lists:
	 - lisi
	 - zhaoliu
	dog:
		name: 小狗
		age: 12
</code></pre>
<ul>
<li>JavaBean</li>
</ul>
<pre><code class="language-java">/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 */
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;
  
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
}
</code></pre>
<ul>
<li>我们可以导入配置文件处理器，以后编写配置就有提示了</li>
</ul>
<pre><code class="language-xml">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>SpringBoot中的测试类</li>
</ul>
<pre><code class="language-java">/**
 * SpringBoot单元测试
 * 可以在测试期间很方便的类似编码一样进行自动注入等容器的功能
 */
@RunWith(SpringRunner.class)
@SpringBootTest
public class DemoApplicationTests {}
</code></pre>
<h4 id="1-properties配置文件在idea中默认utf-8可能会乱码">1、properties配置文件在idea中默认utf-8可能会乱码</h4>
<ul>
<li>调整IDEA中的默认编码<img src="https://Zu3zz.github.io//post-images/1571315004181.png" alt="调整IDEA" loading="lazy"></li>
</ul>
<h4 id="2-value获取值和configurationproperties获取值比较">2、@Value获取值和@ConfigurationProperties获取值比较</h4>
<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定(驼峰与下划线转换)</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL(Spring表达式)</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验(@Validated)</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<ul>
<li>配置文件yml还是properties他们都能获取到值；</li>
<li>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</li>
<li>如果说，我们专门编写了一个JavaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</li>
</ul>
<h4 id="3-配置文件注入值数据校验">3、配置文件注入值数据校验</h4>
<pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated
public class Person {
    /**
     * &lt;bean class=&quot;Person&quot;&gt;
     * 	&lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量、配置文件中获取值/#{Spring表达式}&quot;&gt;
     	&lt;/property&gt;
     * &lt;bean/&gt;
     */
   	// lastName必须是邮箱格式
    @Email
    // @Value(&quot;${person.last-name}&quot;)
    private String lastName;
    // @Value(&quot;#{11*2}&quot;)
    private Integer age;
    // @Value(&quot;true&quot;)
    private Boolean boss;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
}
</code></pre>
<h4 id="4-propertysource-importresource">4、@PropertySource &amp; @ImportResource</h4>
<ul>
<li><strong>@PropertySource:</strong> ： 加载指定的配置文件</li>
</ul>
<pre><code class="language-java">/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *  @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值；
 */
@PropertySource(value = {&quot;classpath:person.properties&quot;})
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
//@Validated
public class Person {
   	//lastName必须是邮箱格式
   	// @Email
    //@Value(&quot;${person.last-name}&quot;)
    private String lastName;
    //@Value(&quot;#{11*2}&quot;)
    private Integer age;
    //@Value(&quot;true&quot;)
    private Boolean boss;
}
</code></pre>
<ul>
<li>
<p><strong>@ImportResource</strong>: 导入Sprinig的配置文件，让配置文件里面的内容生效</p>
</li>
<li>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p>
</li>
<li>
<p>想让Spring的配置文件生效，加载进来，@<strong>ImportResource</strong>标注在一个配置类上</p>
<pre><code class="language-java">@ImportResource(locations = {&quot;classpath:beans.xml&quot;})
导入Spring的配置文件让其生效
</code></pre>
</li>
<li>
<p>不来编写Spring中的配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;helloService&quot; class=&quot;com.zth.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p><strong>上面这种方式在SpringBoot2.x中已经不再使用！！！！！！！</strong></p>
</li>
<li>
<p>SpringBoot推荐给容器中添加组件的方式：推荐使用全注解的方式</p>
<ol>
<li>配置类**@Configuration** -----&gt; Spring配置文件</li>
<li>使用**@Bean**给容器中添加组件</li>
</ol>
<pre><code class="language-java">/**
 * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件
 * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件
 */
@Configuration
public class MyAppConfig {
    //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名
    @Bean
    public HelloService helloService02(){
        System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;);
        return new HelloService();
    }
}
</code></pre>
</li>
</ul>
<h2 id="4-配置文件占位符">4、配置文件占位符</h2>
<h3 id="1-随机数">1、随机数</h3>
<pre><code class="language-java">${random.value}、${random.int}、${random.long}
${random.int(10)}、${random.int[1024,65536]}
</code></pre>
<h3 id="2-占位符获取之前配置的值如果没有可以是用指定默认值">2、占位符获取之前配置的值，如果没有可以是用:指定默认值</h3>
<pre><code class="language-properties">person.last-name=张三${random.uuid}
person.age=${random.int}
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=14
person.lists=a,b,c
person.dog.name=${person.hello:hello}_dog
person.dog.age=15
</code></pre>
<h2 id="5-profile">5、Profile</h2>
<h3 id="1-多profile文件">1、多Profile文件</h3>
<ul>
<li>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</li>
<li>当创建多个文件时，默认使用application.properties的配置；</li>
</ul>
<h3 id="2-yml支持多文档块方式">2、yml支持多文档块方式</h3>
<ul>
<li>yml更简洁一些</li>
</ul>
<pre><code class="language-yml">server:
  port: 8081
spring:
  profiles:
    active: prod # 激活prod环境
---
server:
  port: 8083
spring:
  profiles: dev
---
server:
  port: 8084
spring:
  profiles: prod  #指定属于哪个环境
</code></pre>
<h3 id="3-激活指定profile">3、激活指定profile</h3>
<p>1、在配置文件中指定  spring.profiles.active=dev（yml中配置如上）</p>
<p>2、命令行：</p>
<pre><code class="language-shell">java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；
</code></pre>
<ul>
<li>可以直接在测试的时候，配置传入命令行参数，在IDEA中配置**--spring.profiles.active=dev**</li>
</ul>
<p>3、虚拟机参数；</p>
<pre><code class="language-shell">-Dspring.profiles.active=dev
</code></pre>
<h2 id="6-配置文件加载位置">6、配置文件加载位置</h2>
<ul>
<li>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<ol>
<li>–file:./config/</li>
<li>–file:./</li>
<li>–classpath:/config/</li>
<li>–classpath:/</li>
</ol>
</li>
<li>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
</li>
<li>
<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>
</li>
<li>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
</li>
<li>
<p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p>
<pre><code class="language-shell">java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties
</code></pre>
</li>
</ul>
<h2 id="7-外部配置加载顺序">7、外部配置加载顺序</h2>
<ul>
<li>
<p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p>
<ol>
<li><strong>命令行参数</strong></li>
</ol>
<ul>
<li>
<p>所有的配置都可以在命令行上进行指定</p>
<pre><code class="language-shell">java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc
</code></pre>
</li>
<li>
<p>多个配置用空格分开； --配置项=值</p>
</li>
</ul>
<ol start="2">
<li>来自java: comp/env的JNDI属性</li>
<li>Java系统属性(System.getProperties())</li>
<li>操作系统环境变量</li>
<li>RandomValuePropertySource配置的random.*属性值</li>
<li><strong>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></li>
<li><strong>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></li>
</ol>
</li>
<li>
<p><strong>再来加载不带profile</strong></p>
<ol start="8">
<li><strong>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></li>
<li><strong>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></li>
<li>@Configuration注解类上的@PropertySource</li>
<li>通过SpringApplication.setDefaultProperties指定的默认属性</li>
</ol>
</li>
<li>
<p>所有支持的配置加载来源；<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config">参考官方文档</a></p>
</li>
</ul>
<h2 id="8-自动配置原理">8、自动配置原理</h2>
<ul>
<li>配置文件到底能写什么？怎么写？自动配置原理？</li>
<li><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties">配置文件能配置的属性参照</a></li>
</ul>
<h3 id="1-自动配置原理">1、<strong>自动配置原理</strong></h3>
<ol>
<li>
<p>SpringBoot启动的时候加载主配置类，开启了自动配置功能**@EnableAutoConfiguration**</p>
</li>
<li>
<p><strong>@EnableAutoConfiguration的作用</strong></p>
<ul>
<li>
<p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p>
</li>
<li>
<p>可以查看selectImports()方法的内容</p>
</li>
<li>
<p>List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置</p>
<pre><code class="language-java">SpringFactoriesLoader.loadFactoryNames()
扫描所有jar包类路径下  META-INF/spring.factories
把扫描到的这些文件的内容包装成properties对象
从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中
</code></pre>
</li>
<li>
<p>将类路径下的 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加入到了容器中；</p>
</li>
</ul>
<pre><code class="language-properties"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\...
# 省略若干
</code></pre>
<ul>
<li>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</li>
</ul>
</li>
<li>
<p>每一个自动配置类进行自动配置功能；</p>
</li>
<li>
<p>以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理；</p>
<pre><code class="language-java">// 表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
@Configuration

// 启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpProperties绑定起来；并把HttpProperties加入到ioc容器中
@EnableConfigurationProperties(HttpProperties.class)

// Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)

// 判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnClass(CharacterEncodingFilter.class)

// 判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的
@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)
public class HttpEncodingAutoConfiguration {
  // 这里与SpringBoot配置文件进行映射
  private final HttpProperties.Encoding properties;
  
  // 只有一个有参构造器的情况下，参数的值就会从容器中拿
	public HttpEncodingAutoConfiguration(HttpProperties properties) {
		this.properties = properties.getEncoding();
	}
	@Bean // 给容器中添加一个组件，这个组件的某些值需要从properties中获取
	@ConditionalOnMissingBean // 判断容器中是否有这个组件
	public CharacterEncodingFilter characterEncodingFilter() {
		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
		filter.setEncoding(this.properties.getCharset().name());
		filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
		filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
		return filter;
	}
}
</code></pre>
<ul>
<li>
<p>根据当前不同的条件判断，决定这个配置类，是否生效</p>
</li>
<li>
<p>一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个配置类</p>
<pre><code class="language-java">// 从配置文件中获取指定的值和bean的属性进行绑定
@ConfigurationProperties(prefix = &quot;spring.http&quot;)
public class HttpProperties {
  public static class Encoding {
    public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
  }
}
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><strong>SpringBoot的精髓</strong></p>
<ol>
<li><strong>SpringBoot会加载大量的自动配置类</strong></li>
<li><strong>我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</strong></li>
<li><strong>我们再来看这个自动配置类中到底配置了哪些组件；(只要我们要用的组件有，我们就不需要再来配置了)</strong></li>
<li><strong>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></li>
</ol>
</li>
<li>
<p>xxxxAutoConfigurartion：自动配置类；</p>
</li>
<li>
<p>给容器中添加组件</p>
</li>
<li>
<p>xxxxProperties:封装配置文件中相关属性；</p>
</li>
</ul>
<h3 id="2-细节">2、细节</h3>
<h4 id="1-conditional派生注解spring中原生的conditional作用">1、@Conditional派生注解(Spring中原生的@Conditional作用)</h4>
<ul>
<li>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="2-自动配置类必须在一定的条件下才能生效">2、自动配置类必须在一定的条件下才能生效</h4>
<ul>
<li>
<p>我们怎么知道哪些自动配置类生效？</p>
</li>
<li>
<p><strong>我们可以通过启用  debug=true属性；来让控制台打印自动配置报告</strong>，这样我们可以很方便的知道哪些哪些自动配置类生效</p>
<pre><code class="language-shell">============================
CONDITIONS EVALUATION REPORT
============================
Positive matches: （自动配置类启用的）
-----------------
CodecsAutoConfiguration matched:
    - @ConditionalOnClass found required class 'org.springframework.http.codec.CodecConfigurer' (OnClassCondition)

CodecsAutoConfiguration.JacksonCodecConfiguration matched:
    - @ConditionalOnClass found required class 'com.fasterxml.jackson.databind.ObjectMapper' (OnClassCondition)
    下面若干省略...
    
Negative matches:（没有启动，没有匹配成功的自动配置类）
-----------------
ActiveMQAutoConfiguration:
    Did not match:
        - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)

AopAutoConfiguration:
    Did not match:
        - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)
</code></pre>
</li>
</ul>
<hr>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://Zu3zz.github.io/tag/VaOfOOWC5/">
            <span class="flex-auto">SpringBoot</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://Zu3zz.github.io/tag/tqQSAbU7V/">
            <span class="flex-auto">BackEnd</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://Zu3zz.github.io/tag/_el9BOoeY/">
            <span class="flex-auto">Java</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://Zu3zz.github.io/post/springboot-3/">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  SpringBoot系列(3) ---- 日志
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://Zu3zz.github.io/post/springboot-1/">
                <h3 class="post-title">
                  SpringBoot系列(1) ---- SpringBoot入门
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://Zu3zz.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
