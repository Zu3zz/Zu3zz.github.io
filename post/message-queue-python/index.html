<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>风袖</title>
<meta name="description" content="烟蛾敛略不胜态，风袖低昂如有情" />
<link rel="shortcut icon" href="https://zu3zz.coding.me/favicon.ico?v=1580884801035">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://zu3zz.coding.me/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="风袖 - Atom Feed" href="https://zu3zz.coding.me/atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://zu3zz.coding.me">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://zu3zz.coding.me/images/avatar.png?v=1580884801035" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">风袖</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%BE%83">1. 常用消息中间件比较</a>
<ul>
<li><a href="#11-%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%8B%E7%BB%8D">1.1 常用消息中间件介绍</a></li>
<li><a href="#12-%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94">1.2 常用消息中间件对比</a></li>
</ul>
</li>
<li><a href="#2-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5">2. 消息中间件常见概念</a>
<ul>
<li><a href="#21-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A6%82%E5%BF%B5%E5%92%8C%E8%A7%92%E8%89%B2">2.1 消息中间件中的各种概念和角色</a></li>
<li><a href="#22-%E7%94%9F%E4%BA%A7%E8%80%85">2.2 生产者</a></li>
<li><a href="#23-partition">2.3 Partition</a></li>
<li><a href="#24-%E8%AE%A2%E9%98%85">2.4 订阅</a></li>
<li><a href="#25-%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6">2.5 消息确认机制</a></li>
</ul>
</li>
<li><a href="#3-redis">3. Redis</a>
<ul>
<li><a href="#31-redis%E7%AE%80%E4%BB%8B">3.1 Redis简介</a></li>
<li><a href="#32-redis%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">3.2 Redis常见应用场景</a></li>
<li><a href="#33-redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE">3.3 Redis安装与默认配置</a>
<ul>
<li><a href="#331redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE">3.3.1Redis服务器默认配置</a></li>
<li><a href="#332-redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3.3.2 Redis服务器配置文件</a></li>
<li><a href="#333-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0">3.3.3 常见参数</a></li>
</ul>
</li>
<li><a href="#34-redis%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E5%92%8C%E5%91%BD%E4%BB%A4">3.4 Redis常见操作和命令</a>
<ul>
<li><a href="#341-redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3">3.4.1 Redis常用命令讲解</a></li>
<li><a href="#342-redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8Bstring">3.4.2 Redis常用命令之String</a></li>
<li><a href="#343-redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3%E4%B9%8Bhash">3.4.3 Redis常用命令讲解之Hash</a></li>
<li><a href="#344-redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3%E4%B9%8Blist">3.4.4 Redis常用命令讲解之List</a></li>
<li><a href="#345-redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3%E4%B9%8Bset">3.4.5 Redis常用命令讲解之Set</a></li>
<li><a href="#346-redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3%E4%B9%8Bsorted-set">3.4.6 Redis常用命令讲解之Sorted Set</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-python%E4%B8%8Eredis">4. Python与Redis</a>
<ul>
<li><a href="#41-redis-python%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%8B%E7%BB%8D">4.1 Redis Python客户端介绍</a></li>
<li><a href="#42-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%8F%96%E5%87%BA">4.2 消息队列的插入与取出</a>
<ul>
<li><a href="#421-%E5%9F%BA%E4%BA%8E-redis-py-%E7%94%9F%E4%BA%A7%E8%80%85%E5%BC%80%E5%8F%91">4.2.1 基于 redis-py 生产者开发</a></li>
<li><a href="#422-%E5%9F%BA%E4%BA%8E-redis-py-%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%80%E5%8F%91">4.2.2 基于 redis-py 消费者开发</a></li>
</ul>
</li>
<li><a href="#43-%E5%9F%BA%E4%BA%8E%E9%A2%91%E9%81%93%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85">4.3 基于频道的发布与订阅</a>
<ul>
<li><a href="#431-%E5%9F%BA%E4%BA%8E-redis-py-%E7%94%9F%E4%BA%A7%E8%80%85%E5%BC%80%E5%8F%91">4.3.1 基于 redis-py 生产者开发</a></li>
<li><a href="#432-%E5%9F%BA%E4%BA%8E-redis-py-%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%80%E5%8F%91">4.3.2 基于 redis-py 消费者开发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-kafka">5. Kafka</a>
<ul>
<li><a href="#51-kafka%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">5.1 Kafka简介与应用场景</a></li>
<li><a href="#52-kafka%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">5.2 Kafka常见应用场景</a></li>
<li><a href="#53-kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E7%94%A8%E4%BE%8B">5.3 Kafka安装与简单用例</a>
<ul>
<li><a href="#531-%E5%AE%89%E8%A3%85">5.3.1 安装</a></li>
<li><a href="#532-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">5.3.2 启动服务</a></li>
<li><a href="#533-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAtopic">5.3.3 创建一个Topic</a></li>
<li><a href="#534-%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9">5.3.4 消息的生产与消费</a></li>
</ul>
</li>
<li><a href="#54-kafka%E7%9A%84%E9%85%8D%E7%BD%AE">5.4 Kafka的配置</a>
<ul>
<li><a href="#541-kafka%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5.4.1 Kafka服务器配置文件</a></li>
<li><a href="#542-kafka%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E9%A1%B9">5.4.2 Kafka默认配置项</a></li>
</ul>
</li>
<li><a href="#55-kafka%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">5.5 Kafka相关概念</a>
<ul>
<li><a href="#551-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-%E9%9B%86%E7%BE%A4">5.5.1 常见概念--集群</a></li>
<li><a href="#552-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-%E6%B6%88%E6%81%AF">5.5.2 常见概念--消息</a></li>
<li><a href="#553-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-topic">5.5.3 常见概念--Topic</a></li>
<li><a href="#554-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-partition">5.5.4 常见概念--Partition</a></li>
<li><a href="#555-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-segment">5.5.5 常见概念--Segment</a></li>
<li><a href="#556-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5-%E9%9B%86%E7%BE%A4">5.5.6 常见概念--集群</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-python%E4%B8%8Ekafka">6. Python与Kafka</a></li>
<li><a href="#7-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88">7. 框架整合</a>
<ul>
<li><a href="#71-%E9%87%87%E9%9B%86%E6%97%A5%E5%BF%97">7.1 采集日志</a>
<ul>
<li><a href="#711-%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D">7.1.1 日志采集方案介绍</a></li>
<li><a href="#712-nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE">7.1.2 nginx访问日志格式配置</a></li>
</ul>
</li>
<li><a href="#72-logstash%E9%85%8D%E7%BD%AE">7.2 logstash配置</a>
<ul>
<li><a href="#721-kafka%E6%8F%92%E4%BB%B6">7.2.1 kafka插件</a></li>
</ul>
</li>
<li><a href="#73-%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97">7.3 启动日志</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="/projects" class="menu" style="animation-delay: 0.8s">
          项目
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">By 3zz.</div>
    <a class="rss" href="https://zu3zz.coding.me/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Python与常用消息中间件</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-10-18 / 20 min read
        </div>
        
        <div class="post-content yue">
          <p>🌈最近在学习消息中间件，由于大数据端天生靠近数据，所以在很多场景下，会需要对日志等文件进行分析<br>
🎊那么这一系列，我们使用Python语言对常用的消息中间件进行一次整合<br>
🎉看看如何将nginx、kafka、zookeeper、redis、logstash一起，使用python语言搭建一个日志报警系统吧</p>
<!-- more -->
<h2 id="1-常用消息中间件比较">1. 常用消息中间件比较</h2>
<h3 id="11-常用消息中间件介绍">1.1 常用消息中间件介绍</h3>
<ul>
<li>Redis</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>ZeroMQ</li>
<li>Kafka</li>
</ul>
<h3 id="12-常用消息中间件对比">1.2 常用消息中间件对比</h3>
<ul>
<li>实现语言</li>
<li>对外接口</li>
<li>持久化策略</li>
<li>消息处理模式</li>
<li>时序保证</li>
</ul>
<table>
<thead>
<tr>
<th>消息中间件</th>
<th>实现语言</th>
<th>持久化</th>
<th>消息处理模式</th>
<th>时序保证</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis</td>
<td>C</td>
<td>支持磁盘</td>
<td>Push-Pull Pub-Sub</td>
<td>有序</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>Erlang</td>
<td>磁盘</td>
<td>Push</td>
<td>单消费者有序</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>Java</td>
<td>磁盘</td>
<td>Puch-Pull</td>
<td>同队列有序</td>
</tr>
<tr>
<td>Kafka</td>
<td>Scala</td>
<td>磁盘</td>
<td>Pull</td>
<td>单Paritition有序</td>
</tr>
</tbody>
</table>
<h2 id="2-消息中间件常见概念">2. 消息中间件常见概念</h2>
<h3 id="21-消息中间件中的各种概念和角色">2.1 消息中间件中的各种概念和角色</h3>
<ul>
<li>Producer/borker/cunsumer</li>
<li>Queue/channel/topic</li>
<li>Partition</li>
<li>Publish/subscribe</li>
<li>Acknowledge</li>
</ul>
<h3 id="22-生产者">2.2 生产者</h3>
<figure data-type="image" tabindex="1"><img src="https://zu3zz.coding.me/post-images/1571396146907.png" alt="producer" loading="lazy"></figure>
<h3 id="23-partition">2.3 Partition</h3>
<ul>
<li>一个topic可以分为多个partition</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://zu3zz.coding.me/post-images/1571396164758.png" alt="" loading="lazy"></figure>
<h3 id="24-订阅">2.4 订阅</h3>
<figure data-type="image" tabindex="3"><img src="https://zu3zz.coding.me/post-images/1571396178821.png" alt="" loading="lazy"></figure>
<h3 id="25-消息确认机制">2.5 消息确认机制</h3>
<ul>
<li>只有经过用户确认的消息才会从queue中去除</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://zu3zz.coding.me/post-images/1571396204405.png" alt="" loading="lazy"></figure>
<h2 id="3-redis">3. Redis</h2>
<h3 id="31-redis简介">3.1 Redis简介</h3>
<p><strong>Redis关键词</strong></p>
<ul>
<li>Key-value</li>
<li>高性能</li>
<li>缓存</li>
<li>C开发</li>
<li>五大数据结构</li>
<li>lua扩展</li>
</ul>
<h3 id="32-redis常见应用场景">3.2 Redis常见应用场景</h3>
<ol>
<li>
<p>String</p>
<ul>
<li>缓存二进制对象，比如图片、序列化对象等</li>
<li>计数器，比如文章访问量统计</li>
<li>位运算，节约内存</li>
</ul>
</li>
<li>
<p>List</p>
<ul>
<li>获取最新的N条数据</li>
<li>消息队列</li>
<li>实时分析系统，比如服务器监控程序</li>
</ul>
</li>
<li>
<p>Hash</p>
<ul>
<li>
<p>类似Python中的Dict</p>
</li>
<li>
<p>存储具有多个属性的对象</p>
</li>
<li>
<p>比如用户的年龄、姓名、性别、积分</p>
</li>
</ul>
</li>
<li>
<p>Set</p>
<ul>
<li>集合操作，比如通过交集实现共同关注，共同好友</li>
<li>存储无序不重复数据，比如存储文章标签</li>
</ul>
</li>
<li>
<p>Sorted Set</p>
<ul>
<li>TopN排序，比如排行榜</li>
<li>范围查找，比如判断ip地址所在地</li>
<li>优先级队列</li>
<li>过期项目处理</li>
</ul>
</li>
<li>
<p>Pub Sub</p>
<ul>
<li>实时消息系统</li>
<li>比如即时聊天，群聊</li>
</ul>
</li>
</ol>
<h3 id="33-redis安装与默认配置">3.3 Redis安装与默认配置</h3>
<h4 id="331redis服务器默认配置">3.3.1Redis服务器默认配置</h4>
<ul>
<li>端口号：port=6379</li>
<li>IP地址 bind=0.0.0.0</li>
<li>数据库存放位置 dir=./</li>
<li>数据库名字 dbfilename=dump.rdb</li>
<li>守护进程模式 daemonize=no</li>
</ul>
<h4 id="332-redis服务器配置文件">3.3.2 Redis服务器配置文件</h4>
<ul>
<li>
<p>Redis服务器启用配置文件：运行</p>
<pre><code class="language-shell">redis-server name.conf
</code></pre>
</li>
<li>
<p>查看redis服务器所有选项配置：运行</p>
<pre><code class="language-shell">redis-cli config get '*'
</code></pre>
</li>
<li>
<p>查看redis服务器某个配置选项：运行</p>
<pre><code class="language-shell">redis-cli config get xxx(e.g: bind)
</code></pre>
</li>
</ul>
<h4 id="333-常见参数">3.3.3 常见参数</h4>
<ol>
<li>--daemonize
<ul>
<li>含义：是否以守护进程的形式启动(后台启动)</li>
<li>用法：daemonize yes|no</li>
<li>默认值：no</li>
<li>实例：daemonize yes</li>
</ul>
</li>
<li>--bind
<ul>
<li>含义：redis监听的ip地址</li>
<li>用法：bind ip地址</li>
<li>默认值：127.0.0.1</li>
<li>实例：bind 0.0.0.0(监听所有)</li>
</ul>
</li>
<li>--port(一般不改)
<ul>
<li>含义：redis监听的端口号</li>
<li>用法：port 端口号</li>
<li>默认值：6379</li>
<li>实例：port 6380</li>
</ul>
</li>
<li>--dir
<ul>
<li>含义：redis持久化文件存放目录</li>
<li>用法：dir 文件路径</li>
<li>默认值：./</li>
<li>实例：dir /mnt/redis/data/</li>
</ul>
</li>
<li>--dbfilename
<ul>
<li>含义：redis持久化文件文件名</li>
<li>用法：dbfilename 文件名</li>
<li>默认值：dump.rdb</li>
<li>实例：dbfilename xxxx.rdb(e.g. user.rdb)</li>
</ul>
</li>
<li>--unixsocket(效率高于socket套接字)
<ul>
<li>含义：redis监听的unix套接字地址</li>
<li>用法：unixsocket文件地址</li>
<li>默认值：空</li>
<li>实例：unixsocket /tmp/redis.sock</li>
</ul>
</li>
</ol>
<h3 id="34-redis常见操作和命令">3.4 Redis常见操作和命令</h3>
<p><strong>首先使用redis-server启动redis服务，然后使用redis-cli进入命令行界面</strong></p>
<h4 id="341-redis常用命令讲解">3.4.1 Redis常用命令讲解</h4>
<ul>
<li>测试客户端与服务器连接是否正常：PING</li>
<li>获得符合规则的键名列表：KEYS pattern</li>
<li>判断一个键是否存在：EXISTS key</li>
<li>删除一个键：DEL key</li>
<li>获取键的类型：TYPE key</li>
<li>清空当前数据库所有数据：FLUSHDB</li>
<li>设置一个键的生育生存时间：EXPIRE key seconds</li>
<li>返回一个键的生育生存时间：TTL key</li>
</ul>
<pre><code class="language-shell">127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; keys *
 1) &quot;1558695101775_0.7258740928094547&quot;
 2) &quot;1558693978601_0.21519364815403463&quot;
 3) &quot;1558695158141_0.8666190807031027&quot;
127.0.0.1:6379&gt; flushdb
OK
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt; set foo bar
OK
127.0.0.1:6379&gt; keys foo
1) &quot;foo&quot;
127.0.0.1:6379&gt; type foo
string
127.0.0.1:6379&gt; exists foo
(integer) 1
127.0.0.1:6379&gt; del foo
(integer) 1
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt; set foo bar
OK
127.0.0.1:6379&gt; expire foo 60
(integer) 1
127.0.0.1:6379&gt; ttl foo
(integer) 58
127.0.0.1:6379&gt; ttl foo
(integer) -2
</code></pre>
<h4 id="342-redis常用命令之string">3.4.2 Redis常用命令之String</h4>
<ul>
<li>SET</li>
<li>GET</li>
<li>INCR(递增一个值为整数的string)</li>
<li>MSET(批量设置)</li>
<li>MGET(批量获取)</li>
</ul>
<pre><code class="language-shell">127.0.0.1:6379&gt; set foo barstring
OK
127.0.0.1:6379&gt; get foo
&quot;barstring&quot;
127.0.0.1:6379&gt; get ffo
(nil)
127.0.0.1:6379&gt; mset foo1 bar1 foo2 bar2 foo3 bar3
OK
127.0.0.1:6379&gt; mget foo1 foo2 foo3
1) &quot;bar1&quot;
2) &quot;bar2&quot;
3) &quot;bar3&quot;
127.0.0.1:6379&gt; set num 1
OK
127.0.0.1:6379&gt; incr num
(integer) 2
127.0.0.1:6379&gt; get num
&quot;2&quot;
</code></pre>
<h4 id="343-redis常用命令讲解之hash">3.4.3 Redis常用命令讲解之Hash</h4>
<ul>
<li>HSET</li>
<li>HGET</li>
<li>HMSET</li>
<li>HMGET</li>
<li>HGETALL</li>
<li>HDEL</li>
</ul>
<pre><code class="language-shell">127.0.0.1:6379&gt; hset user name 3zz
(integer) 1
127.0.0.1:6379&gt; hset user sex man
(integer) 1
127.0.0.1:6379&gt; hget user name
&quot;3zz&quot;
127.0.0.1:6379&gt; hgetall user
1) &quot;name&quot;
2) &quot;3zz&quot;
3) &quot;sex&quot;
4) &quot;man&quot;
127.0.0.1:6379&gt; hdel user name
(integer) 1
127.0.0.1:6379&gt; hgetall user
1) &quot;sex&quot;
2) &quot;man&quot;
127.0.0.1:6379&gt; del user
(integer) 1
127.0.0.1:6379&gt; exists user
(integer) 0
</code></pre>
<h4 id="344-redis常用命令讲解之list">3.4.4 Redis常用命令讲解之List</h4>
<ul>
<li>LPUSH(从左侧放入)</li>
<li>RPUSH(从右侧放入)</li>
<li>LPOP(从左侧拿出)</li>
<li>RPOP(从右侧拿出)</li>
<li>BRPOP(有数据则返回，没有就一直等待直到有数据)</li>
<li>LLEN(返回长度)</li>
<li>LRANGE(返回从索引start到end两端的元素，左右都闭)</li>
<li>RPOPLPUSH(先右拿出 左放入)</li>
</ul>
<pre><code class="language-shell">127.0.0.1:6379&gt; lpush list0 a
(integer) 1
127.0.0.1:6379&gt; lpush list0 b c 
(integer) 4
127.0.0.1:6379&gt; lrange list0 0 -1
1) &quot;c&quot;
2) &quot;b&quot;
3) &quot;a&quot;
127.0.0.1:6379&gt; rpush list0 d e
(integer) 5
127.0.0.1:6379&gt; lrange list0 0 -1
1) &quot;c&quot;
2) &quot;b&quot;
3) &quot;a&quot;
4) &quot;d&quot;
5) &quot;e&quot;
127.0.0.1:6379&gt; llen list0
(integer) 5
127.0.0.1:6379&gt; rpoplpush list0 list1
&quot;e&quot;
127.0.0.1:6379&gt; lrange list1 0 -1
1) &quot;e&quot;
127.0.0.1:6379&gt; lrange list0 0 -1
1) &quot;c&quot;
2) &quot;b&quot;
3) &quot;a&quot;
4) &quot;d&quot;
127.0.0.1:6379&gt; rpoplpush list0 list0 
&quot;d&quot;
127.0.0.1:6379&gt; lrange list0 0 -1
1) &quot;d&quot;
2) &quot;c&quot;
3) &quot;b&quot;
4) &quot;a&quot;
127.0.0.1:6379&gt; llen list0
(integer) 4
</code></pre>
<h4 id="345-redis常用命令讲解之set">3.4.5 Redis常用命令讲解之Set</h4>
<ul>
<li>SADD</li>
<li>SREM</li>
<li>SMEMBERS</li>
<li>SISMEMBER</li>
<li>SDIFF(差集)</li>
<li>SINTER(并集)</li>
<li>SUNION(交集)</li>
<li>SCARD(元素个数)</li>
</ul>
<pre><code class="language-shell">127.0.0.1:6379&gt; sadd letters a b
(integer) 2
127.0.0.1:6379&gt; SMEMBERS letters
1) &quot;b&quot;
2) &quot;a&quot;
127.0.0.1:6379&gt; SISMEMBER letters a
(integer) 1
127.0.0.1:6379&gt; sadd setA 1 2 3
(integer) 3
127.0.0.1:6379&gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&gt; sdiff setA setB
1) &quot;1&quot;
127.0.0.1:6379&gt; SINTER seta setb
(empty list or set)
127.0.0.1:6379&gt; SINTER setA setB
1) &quot;2&quot;
2) &quot;3&quot;
127.0.0.1:6379&gt; SUNION setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
127.0.0.1:6379&gt; scard setA
(integer) 3
</code></pre>
<h4 id="346-redis常用命令讲解之sorted-set">3.4.6 Redis常用命令讲解之Sorted Set</h4>
<ul>
<li>ZADD(添加元素)</li>
<li>ZSCORE(获得某个元素)</li>
<li>ZRANGE(按照次序给出存在的元素)</li>
<li>ZRANGEBYSCORE(给出给定range里的所有元素，左右都闭)</li>
<li>ZINCRBY(增加一个元素分数)</li>
</ul>
<pre><code class="language-shell">127.0.0.1:6379&gt; ZADD scoreboard 10 x 20 y 30 z 15 a
(integer) 4
127.0.0.1:6379&gt; zscore scoreboard y
&quot;20&quot;
127.0.0.1:6379&gt; zrange scoreboard 2 3
1) &quot;y&quot;
2) &quot;z&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 15 25
1) &quot;a&quot;
2) &quot;y&quot;
127.0.0.1:6379&gt; ZINCRBY scoreboard 30 x
&quot;40&quot;
</code></pre>
<h2 id="4-python与redis">4. Python与Redis</h2>
<h3 id="41-redis-python客户端介绍">4.1 Redis Python客户端介绍</h3>
<blockquote>
<p><strong>推荐使用redis-py</strong></p>
</blockquote>
<ul>
<li>
<p>Getting Started</p>
<pre><code class="language-shell">&gt;&gt;&gt; import redis
&gt;&gt;&gt; r = redis.StrictRedis(host=&quot;localhost&quot;, port=6379,db=0)
&gt;&gt;&gt; r.set('foo','bar')
True
&gt;&gt;&gt; r.get('foo')
'bar'
</code></pre>
</li>
</ul>
<h3 id="42-消息队列的插入与取出">4.2 消息队列的插入与取出</h3>
<h4 id="421-基于-redis-py-生产者开发">4.2.1 基于 redis-py 生产者开发</h4>
<ul>
<li>
<p>每2秒随机生成一个用户名插入到队列中</p>
</li>
<li>
<p>LPUSH</p>
<pre><code class="language-python"># producer1.py
import redis 
import names
import time

r = redis.StrictRedis(host='localhost', port=6379, db=0)

while True:
  time.sleep(2)
  name = names.get_full_name()
  x = r.lpush('names',name)
  print(x,name)
</code></pre>
</li>
</ul>
<h4 id="422-基于-redis-py-消费者开发">4.2.2 基于 redis-py 消费者开发</h4>
<ul>
<li>
<p>将队列中的用户名按照插入顺序取出并打印到屏幕上</p>
</li>
<li>
<p>BRPOP</p>
<pre><code class="language-python"># consumer1.py
import redis

r = redis.StrictRedis(host='localhost', port=6379, db=0)

def consume(key):
  while(True):
    value = r.brpop(key)
    yield value

for v in consume('names'):
  print(v)
</code></pre>
</li>
</ul>
<h3 id="43-基于频道的发布与订阅">4.3 基于频道的发布与订阅</h3>
<h4 id="431-基于-redis-py-生产者开发">4.3.1 基于 redis-py 生产者开发</h4>
<ul>
<li>
<p>每2秒随机生成一个用户名发布到频道中</p>
</li>
<li>
<p>PUBLISH</p>
<pre><code class="language-python"># producer2.py
import redis 
import names
import time

r = redis.StrictRedis(host='localhost', port=6379, db=0)

while True:
  time.sleep(2)
  name = names.get_full_name()
  x = r.publish('names',name)
  print(x,name)
</code></pre>
</li>
</ul>
<h4 id="432-基于-redis-py-消费者开发">4.3.2 基于 redis-py 消费者开发</h4>
<ul>
<li>
<p>订阅发布用户名的频道，有新的消息时打印到屏幕上</p>
</li>
<li>
<p>SUBSCRIBE</p>
<pre><code class="language-python"># consumer2.py
import redis

r = redis.StrictRedis(host='localhost', port=6379, db=0)

ps = r.pubsub()
ps.subscribe('names')

for item in ps.listen():
  print(item)
</code></pre>
</li>
</ul>
<h2 id="5-kafka">5. Kafka</h2>
<h3 id="51-kafka简介与应用场景">5.1 Kafka简介与应用场景</h3>
<ol>
<li>
<p>Kafka简介-关键词</p>
<ul>
<li>磁盘消息队列</li>
<li>高性能</li>
<li>分布式</li>
<li>Zookeeper</li>
<li>实时流处理</li>
<li>重复消费</li>
</ul>
</li>
<li>
<p>Kafka简介--API</p>
<ul>
<li>生产者API</li>
<li>消费者API</li>
<li>流处理器API</li>
<li>连接器API</li>
</ul>
</li>
<li>
<p>Kafka简介--生产者</p>
<ul>
<li>异步通信，所有网路请求异步发送</li>
<li>批量发送，通过设置batch size或者timeout一次发送多个消息</li>
<li>线程安全，多个线程之间可以共享单个生产者实例</li>
<li>负载均衡，采用内部默认机制或者自定义负载均衡策略</li>
<li>返回结果，返回消息的topic，offset等元数据</li>
</ul>
</li>
<li>
<p>Kafka简介--消费者</p>
<ul>
<li>统一API，不在区分high-level consumer API和low-level consumer API</li>
<li>多次消费，不会删除已消费的信息，允许重复消费</li>
<li>负载均衡，基于partition和consumer group自动负载均衡</li>
<li>流量控制，允许开发者控制每次请求返回消息的条数</li>
</ul>
</li>
<li>
<p>Kafka简介--安全</p>
<ul>
<li>连接认证，连接到服务器的生产者和消费者客户端使用SSL或者SASL进行验证</li>
<li>权限管理，broker连接Zookeeper进行权限管理</li>
<li>加密传输，数据传输进行加密</li>
<li>授权管理，客户端读、写操作可以进行授权管理</li>
</ul>
</li>
<li>
<p>Kafka简介--连接器<br>
<img src="https://zu3zz.coding.me/post-images/1571396233737.jpeg" alt="" loading="lazy"></p>
</li>
</ol>
<h3 id="52-kafka常见应用场景">5.2 Kafka常见应用场景</h3>
<ul>
<li>消息服务器</li>
<li>网站活动跟踪</li>
<li>实时数据流聚合</li>
<li>日志聚合</li>
</ul>
<h3 id="53-kafka安装与简单用例">5.3 Kafka安装与简单用例</h3>
<h4 id="531-安装">5.3.1 安装</h4>
<ol>
<li>
<p>下载并且解压缩kafka安装包 这里选择当前最近的2.3.0版本</p>
<pre><code class="language-shell">$ wget http://apache.website-solution.net/kafka/2.3.0/kafka-2.3.0-src.tgz
$ tar -xzf kafka_2.12-2.3.0.tgz
$ cd kafka_2.12-2.3.0
</code></pre>
</li>
<li>
<p>安装Gradle和Zookeeper，为了方便管理 这里统一使用</p>
<pre><code class="language-shell">$ brew install gradle
$ brew install zookeeper
</code></pre>
</li>
</ol>
<h4 id="532-启动服务">5.3.2 启动服务</h4>
<ol>
<li>
<p>启动Zookeeper</p>
<pre><code class="language-shell">$ bin/zookeeper-server-start.sh config/zookeeper.properties
如果是使用homebrew 直接使用下面两条命令即可
$ zkServer
$ zkCli
</code></pre>
</li>
<li>
<p>启动kafka</p>
<pre><code class="language-bash">$ bin/kafka-server-start.sh config/server.properties
</code></pre>
</li>
</ol>
<h4 id="533-创建一个topic">5.3.3 创建一个Topic</h4>
<ol>
<li>
<p>创建一个测试用Topic</p>
<pre><code class="language-shell">$ bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test
</code></pre>
</li>
<li>
<p>查看当前已经创建的测试Topic</p>
<pre><code class="language-shell">$ bin/kafka-topics.sh --list --bootstrap-server localhost:9092
test1
</code></pre>
<p>输出test1 说明创建成功</p>
</li>
</ol>
<h4 id="534-消息的生产与消费">5.3.4 消息的生产与消费</h4>
<ol>
<li>
<p>通过producer产生消息</p>
<pre><code class="language-shell">$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test
&gt;this is message one
&gt;this is message two
</code></pre>
</li>
<li>
<p>通过comsumer拿到所有当前消息</p>
<pre><code class="language-shell">$ bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning
this is message one
this is message two
</code></pre>
<p>成功输出输入的消息</p>
</li>
</ol>
<h3 id="54-kafka的配置">5.4 Kafka的配置</h3>
<h4 id="541-kafka服务器配置文件">5.4.1 Kafka服务器配置文件</h4>
<ul>
<li>
<p>配置文件位于config/server.properties下</p>
</li>
<li>
<p>通过如下命令将配置文件导出至broker.properties中</p>
<pre><code class="language-shell">$ grep '^[^#]' server.properties &gt; broker.properties
</code></pre>
</li>
<li>
<p>查看broker.properties中去除了注释的内容</p>
<pre><code class="language-shell">broker.id=0
num.network.threads=3
num.io.threads=8
socket.send.buffer.bytes=102400
socket.receive.buffer.bytes=102400
socket.request.max.bytes=104857600
log.dirs=/tmp/kafka-logs
num.partitions=1
num.recovery.threads.per.data.dir=1
offsets.topic.replication.factor=1
transaction.state.log.replication.factor=1
transaction.state.log.min.isr=1
log.retention.hours=168
log.segment.bytes=1073741824
log.retention.check.interval.ms=300000
zookeeper.connect=localhost:2181
zookeeper.connection.timeout.ms=6000
group.initial.rebalance.delay.ms=0
</code></pre>
</li>
</ul>
<h4 id="542-kafka默认配置项">5.4.2 Kafka默认配置项</h4>
<blockquote>
<p>加粗的为重要配置</p>
</blockquote>
<ol>
<li>
<p>Disk IO</p>
<ul>
<li>num.io.threads = 8 设置broker处理磁盘IO的线程数</li>
<li>num.partitions = 1 设置每个topic的分区个数</li>
<li>num.recovery.threads.per.data.dir = 1 配置每个数据恢复时的线程数</li>
<li><strong>log.dirs = /tmp/kafka-logs kafka数据的存放目录</strong></li>
<li>log.retention.hours = 168 消息的存储时间 单位是小时</li>
<li>log.segment.bytes = 1073741824 topic的partition是以segment的形式存储的</li>
<li>log.retention.check.interval.ms=300000 定时检查文件大小</li>
</ul>
</li>
<li>
<p>Network</p>
<ul>
<li>num.network.threads = 3 设置broker处理网络请求的最大线程数 一般可设置为CPU的核数</li>
<li>socket.send.buffer.bytes=102400 socket发送缓冲区的大小；-1即为操作系统默认值</li>
<li>socket.receive.buffer.bytes=102400 接受缓冲区；-1为默认值</li>
<li>socket.request.max.bytes=104857600 每一个socket的最大字节数</li>
</ul>
</li>
<li>
<p>Cluster</p>
<ul>
<li>
<p>zookeeper.connect=localhost:2181 zookeeper的集群地址；值可以有多个，中间用逗号分隔</p>
</li>
<li>
<p>zookeeper.connection.timeout.ms=6000 连接的超时时间</p>
</li>
<li>
<p><strong>broker.id=0 broker在集群中的唯一标识；如果没有，zookeeper从1001开始递增</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="55-kafka相关概念">5.5 Kafka相关概念</h3>
<h4 id="551-常见概念-集群">5.5.1 常见概念--集群</h4>
<ul>
<li>Cluster：集群</li>
<li>Broker：每个服务器都是一个Broker</li>
<li>Producer：生产者</li>
<li>Consumer：消费者</li>
<li>Consumer Group：实现topic广播的手段</li>
</ul>
<h4 id="552-常见概念-消息">5.5.2 常见概念--消息</h4>
<ul>
<li>Record：每一条消息</li>
<li>Topic：每一个消息都会有一个Topic</li>
<li>Partition：每个Topic包含一个或者多个Partition</li>
<li>Segment：每个Partition包含一个或者多个Segment</li>
<li>Offset：Partition中每个消息都有的序列号，可以唯一标识一条消息</li>
<li>Replication：副本；kafka支持以Partition为单位对消息进行备份</li>
<li>Leader：所有读写请求都由Leader来处理</li>
</ul>
<h4 id="553-常见概念-topic">5.5.3 常见概念--Topic</h4>
<ul>
<li>
<p>Topic可以被看做是一个队列</p>
<figure data-type="image" tabindex="5"><img src="https://zu3zz.coding.me/post-images/1571396270203.png" alt="topic" loading="lazy"></figure>
</li>
</ul>
<h4 id="554-常见概念-partition">5.5.4 常见概念--Partition</h4>
<figure data-type="image" tabindex="6"><img src="https://zu3zz.coding.me/post-images/1571396287204.png" alt="partition" loading="lazy"></figure>
<h4 id="555-常见概念-segment">5.5.5 常见概念--Segment</h4>
<figure data-type="image" tabindex="7"><img src="https://zu3zz.coding.me/post-images/1571396308603.png" alt="segment" loading="lazy"></figure>
<h4 id="556-常见概念-集群">5.5.6 常见概念--集群</h4>
<figure data-type="image" tabindex="8"><img src="https://zu3zz.coding.me/post-images/1571396330337.png" alt="集群" loading="lazy"></figure>
<h2 id="6-python与kafka">6. Python与Kafka</h2>
<ul>
<li>由于有很多python库都可以使用kafka</li>
<li>知名的有kafka-python；pykafka；faust；这里使用kafka-python</li>
</ul>
<blockquote>
<p>使用pip安装</p>
<p>pip install kafka-python</p>
</blockquote>
<ol>
<li>
<p>创建kafkaProducer.py</p>
<pre><code class="language-python">from kafka import KafkaProducer
import names

producer = KafkaProducer()

for _ in range(10):
    name = names.get_full_name()
    future = producer.send('test', bytes(name,'utf-8'))
    result = future.get(60)
    print(result)
</code></pre>
</li>
<li>
<p>创建kafkaConsumer.py</p>
<pre><code class="language-python">from kafka import KafkaConsumer

consumer = KafkaConsumer('test',group_id='test01')

for msg in consumer:
    print(msg)
</code></pre>
</li>
<li>
<p>进行数据的产生与消费</p>
<pre><code class="language-shell">$ python kafkaProducer.py 
RecordMetadata(topic='test', partition=0, topic_partition=TopicPartition(topic='test', partition=0), offset=14, timestamp=1571317704074, checksum=None, serialized_key_size=-1, serialized_value_size=15, serialized_header_size=-1)
RecordMetadata(topic='test', partition=0, topic_partition=TopicPartition(topic='test', partition=0), offset=15, timestamp=1571317704182, checksum=None, serialized_key_size=-1, serialized_value_size=12, serialized_header_size=-1)
...
</code></pre>
<pre><code class="language-shell">$ python kafkaConsumer.py 
ConsumerRecord(topic='test', partition=0, offset=14, timestamp=1571317704074, timestamp_type=0, key=None, value=b'Margaret Medina', headers=[], checksum=None, serialized_key_size=-1, serialized_value_size=15, serialized_header_size=-1)
ConsumerRecord(topic='test', partition=0, offset=15, timestamp=1571317704182, timestamp_type=0, key=None, value=b'Mark Mccarty', headers=[], checksum=None, serialized_key_size=-1, serialized_value_size=12, serialized_header_size=-1)
...
</code></pre>
<p>可以看到，通过Producer产生的数据已经被Consumer成功拿到。</p>
</li>
</ol>
<h2 id="7-框架整合">7. 框架整合</h2>
<h3 id="71-采集日志">7.1 采集日志</h3>
<h4 id="711-日志采集方案介绍">7.1.1 日志采集方案介绍</h4>
<ul>
<li>flume</li>
<li>rsyslog</li>
<li>heka</li>
<li>logstash</li>
</ul>
<h4 id="712-nginx访问日志格式配置">7.1.2 nginx访问日志格式配置</h4>
<ul>
<li>
<p>自定义日志格式</p>
</li>
<li>
<p>直接输出json</p>
<pre><code class="language-shell">log_format json '{&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,'
								'&quot;host&quot;:&quot;$server_addr&quot;,'
								'&quot;clientip&quot;:&quot;$remote_addr&quot;,'
								'&quot;size&quot;:$body_bytes_sent,'
								'&quot;responsetime&quot;:$request_time,'
								'&quot;upstreamtime&quot;:&quot;$upstream_response_time&quot;,'
								'&quot;upstreamhost&quot;:&quot;$upstream_addr&quot;,'
								'&quot;http_host&quot;:&quot;$host&quot;,'
								'&quot;url&quot;:&quot;$url&quot;,'
								'&quot;xff&quot;:&quot;$http_x_forwarded_for&quot;,'
								'&quot;refer&quot;:&quot;$http_referer&quot;,'
								'&quot;agent&quot;:&quot;$http_user_agent&quot;,'
								'&quot;status&quot;:&quot;$status&quot;}';
asscess_log /tmp/nginx/access.log json;
</code></pre>
</li>
<li>
<p>可以看到nginx的access日志就是json格式的了</p>
</li>
</ul>
<h3 id="72-logstash配置">7.2 logstash配置</h3>
<ul>
<li>logstash配置主要分为以下三个部分
<ol>
<li>input</li>
<li>filter</li>
<li>output</li>
</ol>
</li>
</ul>
<h4 id="721-kafka插件">7.2.1 kafka插件</h4>
<ul>
<li>
<p>配置logstash output kafka插件</p>
<pre><code class="language-shell">input {
    file {
        path =&gt; &quot;/pot/openresty/nginx/logs/access.log&quot;
        codec =&gt; json
    }
}
filter {
    # 对useragent进行预处理
    useragent {
        source =&gt; &quot;agent&quot;
        target =&gt; &quot;user_agent&quot;
        remove_field =&gt; &quot;agent&quot;
    }
    # 对ip地址的地区进行预处理
    geoip {
        source =&gt; &quot;clientip&quot;
        target =&gt; &quot;geoip&quot;
    }
}
output {
    # debug用
    stdout {
        codec =&gt; rubydebug
    }
    # logstash output kafka插件
    kafka {
        codec =&gt; json
        topic_id =&gt; &quot;nginx&quot;
        # kafka对外地址
        bootstrap_servers =&gt; &quot;localhost:9092&quot;
    }
}
</code></pre>
</li>
</ul>
<h3 id="73-启动日志">7.3 启动日志</h3>
<p><strong>依次运行一下应用</strong></p>
<ul>
<li>nginx</li>
<li>logstash</li>
<li>kafka</li>
<li>Zookeeper</li>
</ul>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://zu3zz.coding.me/tag/ITpFJisjB">
            <span class="flex-auto">Nginx</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://zu3zz.coding.me/tag/gkOi3b2wx">
            <span class="flex-auto">Zookeeper</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://zu3zz.coding.me/tag/jmeIOwq49">
            <span class="flex-auto">Python</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://zu3zz.coding.me/tag/tqQSAbU7V">
            <span class="flex-auto">BackEnd</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://zu3zz.coding.me/tag/VQJGfklWj">
            <span class="flex-auto">Kafka</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://zu3zz.coding.me/tag/FlCGh236W">
            <span class="flex-auto">Redis</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://zu3zz.coding.me/post/mysql-1">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  深入浅出MySQL(1) ---- 基础与概念
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://zu3zz.coding.me/post/springboot-3">
                <h3 class="post-title">
                  SpringBoot系列(3) ---- 日志
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://zu3zz.coding.me/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
